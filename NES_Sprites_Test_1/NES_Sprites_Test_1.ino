#include <Adafruit_GFX.h>   // Core graphics library
#include <RGBmatrixPanel.h> // Hardware-specific library

#define CLK 8  // MUST be on PORTB! (Use pin 11 on Mega)
#define OE  9
#define LAT 10
#define A   A0
#define B   A1
#define C   A2
#define D   A3

RGBmatrixPanel matrix(A, B, C, D, CLK, LAT, OE, false);

static const uint32_t TEST_PATTERN_PALETTE[] = {0xff0000, 0x00ff00, 0x0000ff, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000, 0x000000};

static const int8_t TEST_PATTERN_FRAME[] PROGMEM = {
    0x12,0x31,0x23,0x12,0x31,0x23,0x12,0x31,
    0x12,0x31,0x23,0x12,0x31,0x23,0x12,0x31,
    0x12,0x31,0x23,0x12,0x31,0x23,0x12,0x31,
    0x12,0x31,0x23,0x12,0x31,0x23,0x12,0x31,
    0x12,0x31,0x23,0x12,0x31,0x23,0x12,0x31,
    0x12,0x31,0x23,0x12,0x31,0x23,0x12,0x31,
    0x12,0x31,0x23,0x12,0x31,0x23,0x12,0x31,
    0x12,0x31,0x23,0x12,0x31,0x23,0x12,0x31,
    0x12,0x31,0x23,0x12,0x31,0x23,0x12,0x31,
    0x12,0x31,0x23,0x12,0x31,0x23,0x12,0x31,
    0x12,0x31,0x23,0x12,0x31,0x23,0x12,0x31,
    0x12,0x31,0x23,0x12,0x31,0x23,0x12,0x31,
    0x12,0x31,0x23,0x12,0x31,0x23,0x12,0x31,
    0x12,0x31,0x23,0x12,0x31,0x23,0x12,0x31,
    0x12,0x31,0x23,0x12,0x31,0x23,0x12,0x31,
    0x12,0x31,0x23,0x12,0x31,0x23,0x12,0x31};

static const int8_t TEST_PATTERN_FRAME_BYTE[] PROGMEM = {
    0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,
    0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,
    0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,
    0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,
    0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,
    0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,
    0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,
    0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,
    0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,
    0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,
    0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,
    0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,
    0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,
    0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,
    0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,
    0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01,0x02,0x03,0x01};

// We're making these globals to save stack space.
int row;                        ///< Row count, when looping.
int col;                        ///< Column count, when looping.
unsigned long colorValue;       ///< The actual RRGGBB hex color value.
unsigned char paletteIndex;     ///< Index into the color palette.
unsigned long pixelPosition;    ///< Index into the pixel array.

void setup() 
{
    matrix.begin();
    matrix.fillScreen(matrix.Color333(0, 0, 0));
}

void draw16x16ByNibble(const unsigned char *pixels, const unsigned long *palette)
{
    pixelPosition = 0;
    for (row = 0; row < 16; row++)
    {
        for (col = 0; col < 16; col++)
        {
            colorValue = 0; // Assume transparent is black.
            paletteIndex = pgm_read_byte(pixels + pixelPosition); // Find the byte containing the two pixels.
            if (0 == col % 2)
                paletteIndex = paletteIndex >> 4;
            else
                paletteIndex = paletteIndex & 0x0F;
            if (paletteIndex > 0 && paletteIndex < 16)
                colorValue = *(palette + paletteIndex - 1);
            matrix.drawPixel(row, col, matrix.Color888((colorValue >> 16) & 0xFF, (colorValue >> 8) & 0xFF, colorValue & 0xFF)); 
            if (col % 2 == 1)
                pixelPosition++;
        }
    }
}

void draw16x16ByByte(const int8_t *pixels, const unsigned long *palette)
{
    pixelPosition = 0;
    for (row = 0; row < 16; row++)
    {
        for (col = 0; col < 16; col++)
        {
            colorValue = 0; // Assume transparent is black.
            paletteIndex = pgm_read_byte(pixels + pixelPosition); // Find the byte containing the pixel.
            if (paletteIndex > 0 && paletteIndex < 16)
                colorValue = palette[paletteIndex - 1];
            matrix.drawPixel(row, col, matrix.Color888((colorValue >> 16) & 0xFF, (colorValue >> 8) & 0xFF, colorValue & 0xFF)); 
            pixelPosition += 1;
        }
    }
}

void drawTestPattern(const unsigned char *pixels, const unsigned long *palette)
{
    int counter = 0;
    for (row = 0; row < 16; row++)
    {
        for (col = 0; col < 16; col++)
        {
            colorValue = 0; // Assume transparent is black.
            switch(counter)
            {
                case 0: colorValue = 0xff0000; break;
                case 1: colorValue = 0x00ff00; break;
                case 2: colorValue = 0x0000ff; break;
            }
            counter = (counter + 1) % 3;
            matrix.drawPixel(col, row, matrix.Color888((colorValue >> 16) & 0xFF, (colorValue >> 8) & 0xFF, colorValue & 0xFF)); 
        }
    }
}

void loop() 
{
    static const uint8_t TEST_CASE = 3;
    switch(TEST_CASE)
    {
        case 1: drawTestPattern(TEST_PATTERN_FRAME_BYTE, TEST_PATTERN_PALETTE); break;
        case 2: draw16x16ByByte(TEST_PATTERN_FRAME_BYTE, TEST_PATTERN_PALETTE); break;
        case 3: draw16x16ByNibble(TEST_PATTERN_FRAME, TEST_PATTERN_PALETTE); break;
    }
    delay(1000);
}
